triage leaf stem branch = t (t leaf stem) branch
let x f = f x

# SKI combinators
id x = x
K = t t
S = t (t (t t t)) t
I = t (t (t t)) t
U = t (t id) id
B = S (K S) K
C = S (B B S) (K K)
W = S S (K S)
Y = B U (C B U)

fst l r = l
snd l r = r

# Bools
true = t
false = t t
if b tt ff = triage tt (fst ff) t b
not b = if b false true
or a b = if a true b
and a b = if a b false
and3 a b c = and (and a b) c
xor2 a b = if a (not b) b
xor3 a b c = xor2 (xor2 a b) c
majority a b c = if a (or b c) (and b c)

# Lists
nil = t
cons e list = t e list

listmatch list isNil isCons = triage isNil t isCons list

head list = triage false t fst list
tail list = triage nil t snd list
isEmpty list = listmatch list true (\_ \_ false)

# Selects the last element of the list
lastOrDefault list default = listmatch list default \hd \tl lastOrDefault tl hd

filter f list = listmatch list nil \hd \tl 
  let (filter f tl) \rest
  if (f hd)
    (cons hd rest)
    rest

takeWhile f list = listmatch list nil \hd \tl 
  if (f hd)
    (cons hd (takeWhile f tl))
    nil

# Numbers
# numbers are lists of bools. Least significant bit is at the top of the tree.

isZero n = isEmpty $ filter id n
isEven n = or (isEmpty n) (not (head n))

# n <= m 
# 1nnn
# 0mmm

lte n m = if (and (isEmpty n) (isEmpty m)) true $
  if (and (head n) (not (head m)))
    (not (lte (tail m) (tail n)))
    (lte (tail n) (tail m))


_add carry n m = 
  let (and3 (not carry) (isEmpty n) (isEmpty m)) \done
  let (xor3 carry (head n) (head m)) \bit
  let (majority carry (head n) (head m)) \newCarry
  if (done)
    nil
    (cons bit (_add newCarry (tail n) (tail m)))
    

add = _add false

_fib a b = cons b (_fib b (add a b))
fib = _fib 1 1

# Euler 2
evenfibs = filter isEven fib
firstEvenFibs = takeWhile (\n lte n 4_000_000) evenfibs
sum list = if (isEmpty list) 0 (add (head list) (sum (tail list)))

result = sum firstEvenFibs

mul n m = listmatch n 0 \hd \tl
  add (if hd m nil) (cons false $ mul tl m)

sub1 n = if (head n) 
    (cons false (tail n)) 
    (cons true (sub1 (tail n)))

sub n m = if (isEmpty m) 
    n 
    $ let (sub (tail n) (tail m)) \subtree
    if (xor2 (head m) (head n)) 
        (cons true (
            if (head n) 
                subtree
                (sub1 subtree)))
        (cons false subtree)


# 100100101
#  101      -
# ---------
# lF = 64
#  10000101
#       101

# Pairs
pair a b = t a b
left p = triage t t fst p
right p = triage t t snd p

_powersOfTwo n = cons n $ _powersOfTwo (mul 2 n)
powersOfTwo = _powersOfTwo 1

# returns the pair (q, r)
divmod n d = if (not (lte d n))
  (pair 0 n) $
  let (takeWhile (\x lte (mul x d) n) powersOfTwo) \pows
  let (lastOrDefault pows 1) \largestFactor
  let (sub n (mul largestFactor d)) \rest
  let (divmod rest d) \innerPair
  pair (add largestFactor (left innerPair)) (right innerPair)

div n d = left $ divmod n d
mod n d = right $ divmod n d

isDivisible n d = isZero $ mod n d

# Project euler 3

_nats n = cons n $ _nats (add 1 n)
nats = _nats 0


_divisors n d =
  if (isZero n) (cons 0 nil) $
  if (isZero $ sub1 n) nil $
  let (divmod n d) \p
  if (isZero $ right p)
    (cons d $ _divisors (left p) d)
    (_divisors n (add 1 d))
divisors n = _divisors n 2

